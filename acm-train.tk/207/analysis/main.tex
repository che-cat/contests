\documentclass[a4paper,12pt]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel} 
\usepackage{indentfirst} 
\usepackage[dvips]{graphicx}

\usepackage{hyperref}

\newcounter{taskcounter}
\setcounter{taskcounter}{1}
\newcommand{\task}{\section*{Задача \Alph{taskcounter}.\stepcounter{taskcounter}}}

\usepackage{geometry} 
\geometry{left=3.0cm}
\geometry{right=1.5cm}
\geometry{top=2.0cm}
\geometry{bottom=2.0cm}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsthm}

\title{Разбор задач}
\author{Иван~Горбачев\\
\small \texttt{gorbachev.ivan@gmail.com}}
\date{\today}

\begin{document}

\maketitle

\task
Для начала для каждого солдата нужно посчитать <<показатель роста>>. После этого мы можем идти двумя указателями по массиву и выбрать максимум из подотрезков.

Есть несколько методов для подсчета <<показетеля роста>>:
\begin{enumerate}
   \item Возьмем исходный массив и посортируем его. Далее для каждого элемента в отсортированном массиве найдем позицию первого элемента, на которую рассматриваемый элемент можно вставить, чтобы он был больше всех элементов левее его. В С++ реализована данная функция - lower\_bound. Количество элементов в отсортированном массиве меньших, чем текущий, и является <<показателем роста>> рассматриваемого элемента. Ассимптотика - $O(N\cdot \log{N})$.
    
   \item Воспользуемся какой-нибудь структурой данных, которая умеет отвечать на запросы вида get\_elements\_count(0, r), например, \href{http://e-maxx.ru/algo/fenwick_tree}{деревом Фенвика}. Тут возникает проблема следующая: дело в том, что в фенвике мы храним для каждой высоты солдата количество солдат с этим ростом. Рост солдат у нас до $10^9$, а это значит мы не сможем выделить столько памяти. Заметим, что нам не важен конкретное значение роста солдата - нам важен порядок друг относительно друга. Т.е. $(10, 20, 5)$ в принципе эквивалентно в нашей задаче $(1,2,0)$. Это значит, что мы можем <<сжать>> значения - переприсвоить высотам солдатам значения так, чтобы сохранить их относительный порядок. После такой операции максимальная высота солдата у нас будет не более $10^5$ (максимальное количество солдат). Далее используем стандартный фенвик.
\end{enumerate}

В своем решении я использовал второй подход.

\href{https://github.com/mastersobg/olymparch/blob/master/acm-train.tk/207/A/main.cpp}{Моё решение}

\task
В задаче нужно сделать то, что требуется в условии. 

\href{https://github.com/mastersobg/olymparch/blob/master/acm-train.tk/207/B/main.cpp}{Моё решение}

\task
Данная задача относится к классу задач, в которых нужно для начала написать простое переборное решение, которое работает на маленьких числа. Сгенерить ответ для маленьких чисел и попытаться на них увидеть закономерность. Собственно, это я и сделал. 


\href{https://github.com/mastersobg/olymparch/blob/master/acm-train.tk/207/C/main.cpp}{Моё решение}

\task
Пусть $dp[i][j]$ --- это вероятность того, что игра завершится со счетом первого игрока $i$, а второго --- $j$. Ясно, что $dp[0][0] = 1.0$. Рассмотрим переходы:
\begin{itemize}
    \item $dp[i+1][j] += dp[i][j] \cdot p$, где $p$ - вероятность того, что выиграет первый игрок;
    \item $dp[i][j+1] += dp[i][j] \cdot p$, где $p$ - вероятность того, что выиграет второй игрок.
\end{itemize}

Важно правильно определять $p$, т.к. в зависимости от номера матча меняются площадки и соответственно вероятности выиграша того или иного игрока. Подробности можно посмотреть в моем решении.

\href{https://github.com/mastersobg/olymparch/blob/master/acm-train.tk/207/D/main.cpp}{Моё решение}

\task
Нам дан граф. Нам необходимо удалить некоторое количество вершин и не нарушить возможность добраться из каждой вершины в каждую. Т.е. по сути нам нужно получить дерево. Известно, что в дереве количество ребер равно $n-1$, где $n$ --- количество вершин в нем. Значит мы можем удалить из исходного графа $m-n+1$ ребро. Далее посмотрим на четность этого числа (ведь они удаляют ребра по очереди) и выведем имя победителя.


\href{https://github.com/mastersobg/olymparch/blob/master/acm-train.tk/207/E/main.cpp}{Моё решение}


\task
Задача решается рекурсивным перебором. Оценим время работы перебора. Максимальное количество монстров у нас не превышает 1024 ($2^{10}$). Это значит, что рекурсия в глубину у нас не уйдет более, чем на 10. На каждой итерации рекурсия <<расщепляется>> не более, чем на 5 ветвей. $5^{10}=9765625$ - 10 млн. итераций с запасом укладываются в 2 секунды.

\href{https://github.com/mastersobg/olymparch/blob/master/acm-train.tk/207/F/main.cpp}{Моё решение}

\task
Задача на реализацию. Пройдемся по всем датам от minDate до maxDate и будем сравнивать даты с шаблоном.


\href{https://github.com/mastersobg/olymparch/blob/master/acm-train.tk/207/G/main.cpp}{Моё решение}

\task
Воспользуемся методом динамического программирования. Состоянием в этом задаче будет $dp[letter][button]$, где $letter$ --- сколько букв алфавита мы уже разместили на $button-1$ кнопках, а $button$ --- сколько кнопок мы задействовал. Переход: $dp[letter][button] = max(dp[letter+i][button+1] + sum_i)$, где $i$ --- количесто букв, которые мы кладем на текущую кнопку. В своем решении я реализовал типичную рекурсию с мемоизацией. Также стоит не забыть, что нам нужно восстановить ответ, поэтому для каждого состояния мы запоминаем, куда из него мы перешли (массив $prev$ у меня).


\href{https://github.com/mastersobg/olymparch/blob/master/acm-train.tk/207/H/main.cpp}{Моё решение}

\end{document}

